# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' ParseBrukerXML.
#'
#' Reads a Bruker's xml file exported using fleximaging.
#' A list is returned where each element in the list is named according the ROI name.
#' Each element in the list consists in a data.frame with the pixels XY coordinates inside each ROI.
#'
#' @param xml_path the full path where XML file is stored.
#'
#' @return ROI pixel coordinates arranged in a named list.
#' 
CparseBrukerXML <- function(xml_path) {
    .Call(`_rMSI_CparseBrukerXML`, xml_path)
}

#' Testing the imzMLreader
#' testingimzMLBinRead
#' @param ibdFname: full path to the ibd file.
#' @param NPixels: Total number of pixels in the image.
#' @param N: number of elemetns (or data point to read).
#' @param offset: offset in bytes at which the reading operation is started.
#' @param read_mz: if true m/z data is readed, otherwise intensities are readed.
#' @param continuous: true if imzML data is in continuous mode
.debug_imzMLBinReader <- function(ibdFname, NPixels, N, offset, dataTypeString, read_mz, continuous) {
    .Call(`_rMSI_testingimzMLBinRead`, ibdFname, NPixels, N, offset, dataTypeString, read_mz, continuous)
}

CimzMLParse <- function(xml_path) {
    .Call(`_rMSI_CimzMLParse`, xml_path)
}

CimzMLStore <- function(fname, imgInfo) {
    .Call(`_rMSI_CimzMLStore`, fname, imgInfo)
}

#' @importFrom Rcpp evalCpp
#' @useDynLib rMSI, .registration = TRUE
NULL

#' MergeMassAxis.
#' 
#' Merges two mass axis in a single one using an apropiate bin size.
#' The resulting mass axis will display a bin size equal to the minimum of two supplied vectors. 
#' The bin size is calculated relative to the m/z for better accuracy.
#' The resulting mass axis range is calculated using the common range between the two mass axis.
#' If there is no overlao between the two mass axis range an error will be raised.
#' 
#' @param mz1 the first mass axis to merge.
#' @param mz2 the second mass axis to merge.
#' 
#' @return a list containing the common mass axis that represents mz1 and mz1 accurately and a boolean indicating if and error was raised.
#' @export
#' 
MergeMassAxis <- function(mz1, mz2) {
    .Call(`_rMSI_MergeMassAxis`, mz1, mz2)
}

#' @importFrom Rcpp evalCpp
#' @useDynLib rMSI, .registration = TRUE
NULL

ReduceDataPointsC <- function(mass, intensity, massMin, massMax, npoints) {
    .Call(`_rMSI_ReduceDataPointsC`, mass, intensity, massMin, massMax, npoints)
}

#' decodePngStream2IonImage.
#'
#' Obtain a single mass channel ion image be decoding the hdd png stream at a specified ionIndex.
#'
#' @param ionIndex the index of ion to extract from the png stream. //TODO starting by 0 o 1? Im going to call this from R or from C++?
#' 
#' @return A NumerixMatrix containing the ion image. //TODO think if row and cols correspond to witdh and height or visaversa
#' 
NULL

#' TODO ideas varies:
#' 
#' - utilitzar un XML de la mateixa forma que fa imzML per tal d'agregar de forma ordenada tot el que necessitis en un binary:
#'   -- Tot el que no pot estar en imzML de espectres: coordenas corregides (actualment pos), normalizacions, etc...
#'   -- Nou ramdisk basat en png: png stream + factor d'escalat de cada m/z channel, pot seguir la seguent trama binaria:
#'         factor_escalat(float 32bit) + png_stream(N bits) [aixo es repetiria per cada pixel]
#'   -- Peak matrix resultant del rMSIproc, seria un camp opcional: m/z vector (centroides), SNR, Intensity i Area (no caldria guardar ni normalizacions i coordenas pq ja hi son!)
#'      
#' - compatibilitat: puc fer que el nou rMSI i rMSIproc detecti automaticament si les dades son nou o antic format i ho carregui?
#' 
#' - comentar coses en el lodepng.h per fer el binary resultant mes petit: el que no facis servir fora! esta documentat en el propi lodepng.h
#' 
#' - imzML processats: no cal crear el imzML continu equivalent, pots mantenir el processat com a "ramdisk" i constriuir els png mitjancant funcio
#'   approx() o interpolacio. Aixi doncs, un paramatre sera l'eix de massa merged previament calculat. 
#'   Es a dir rMSI no convertira imzML processat en continu sino que simplement calculara leix d massa commu i fara servir una interpolacio quan calgui obtenir un espectre concret.
#'   El mateix passara en la part d processat d rMSIproc, en anar carregant espectres s'anira calculant la interpolacio "on the fly"
#'
#' - ajuntar rMSI i rMSIproc: importar tots els metodes de rMSIproc dins del rMSI, es a dir, rMSIproc deixara d existir. Aixi sera mes facil d mantenir.
#'   tb em permetra fer us d funcions d rMSIproc en rMSI (per exemple multi-threading d boost)
#'   oju amb el Namespace d R, crec que rMSI el fa automatic amb roxigen i rMSIproc el fa manual, que vull al final?
#'
#' - creacio d pngstream amb 2 threads. un thread accedeix a disc i l'altre fa encoding. 
#'   Axi sera mes rapid pq mentres un thread fa encoding laltre ja va carregnat el seguent buffer.
#'   
#' - Reconstruccio d'imatges multi-threading. Per construir la imatge dun io i mostrar-la per pantalla cal llegir N png's del pngstream 
#'   (on N correspont al numero d mass chanels o frames de disc), per tan N es correspon amb el valor de tolerancia selecionat per usuari.
#'   La lectura de disc la faria un sol thread k carregaria en RAM N frames. Despres, varis threads es poden repartir la feina de fer el decoding dels N frames.
#'     
NULL

testingLodepng <- function() {
    invisible(.Call(`_rMSI_testingLodepng`))
}

#' Testing the creation of imgStream
#' testing_imgStreamCreator
#' @param name: desc. 
.debug_imgStreamCreator <- function(rMSIobj) {
    invisible(.Call(`_rMSI_testing_imgStreamCreator`, rMSIobj))
}

