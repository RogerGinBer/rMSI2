# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' ParseBrukerXML.
#'
#' Reads a Bruker's xml file exported using fleximaging.
#' A list is returned where each element in the list is named according the ROI name.
#' Each element in the list consists in a data.frame with the pixels XY coordinates inside each ROI.
#'
#' @param xml_path the full path where XML file is stored.
#'
#' @return ROI pixel coordinates arranged in a named list.
#' 
CparseBrukerXML <- function(xml_path) {
    .Call('_rMSI_CparseBrukerXML', PACKAGE = 'rMSI', xml_path)
}

#' Cload_imzMLSpectra
#' Load spectra into a Matrix object interpolating to the common mass axis when necessary.
#' @param ibdFname: full path to the ibd file.
#' @param continuous: true if imzML data is in continuous mode
#' @param mass: data common mass axis.
#' @param mz_dataTypeString: mass encoding data type name.
#' @param int_dataTypeString: mass encoding data type name.
#' @param offsets: subset of the run data of the imzML parsed file.
Cload_imzMLSpectra <- function(ibdFname, continuous, mass, mz_dataTypeString, int_dataTypeString, offsets) {
    .Call('_rMSI_Cload_imzMLSpectra', PACKAGE = 'rMSI', ibdFname, continuous, mass, mz_dataTypeString, int_dataTypeString, offsets)
}

#' Testing the imzMLreader
#' testingimzMLBinRead
#' @param ibdFname: full path to the ibd file.
#' @param NPixels: Total number of pixels in the image.
#' @param N: number of elemetns (or data point to read).
#' @param offset: offset in bytes at which the reading operation is started.
#' @param read_mz: if true m/z data is readed, otherwise intensities are readed.
#' @param continuous: true if imzML data is in continuous mode
.debug_imzMLBinReader <- function(ibdFname, NPixels, N, offset, dataTypeString, read_mz, continuous) {
    .Call('_rMSI_testingimzMLBinRead', PACKAGE = 'rMSI', ibdFname, NPixels, N, offset, dataTypeString, read_mz, continuous)
}

CimzMLParse <- function(xml_path) {
    .Call('_rMSI_CimzMLParse', PACKAGE = 'rMSI', xml_path)
}

CimzMLStore <- function(fname, imgInfo) {
    .Call('_rMSI_CimzMLStore', PACKAGE = 'rMSI', fname, imgInfo)
}

#' CalcMassAxisBinSize.
#' 
#' Calc the bin size of a mass axis at each mass channels using simple peak-picking information.
#' 
#' @param mass the mass axis.
#' @param intensity the intensity of a given spectrum.
#' 
#' @return the bin size of each m/z channel.
#' @export
#' 
CalcMassAxisBinSize <- function(mass, intensity) {
    .Call('_rMSI_CalcMassAxisBinSize', PACKAGE = 'rMSI', mass, intensity)
}

#' MergeMassAxis.
#' 
#' Merges two mass axis in a single one using an apropiate bin size.
#' The resulting mass axis will display a bin size equal to the minimum of two supplied vectors. 
#' The bin size must be supplied along each input mass axis.
#' The first mass axis (mz1) can be a zero-length vector.
#' 
#' @param mz1 the first mass axis to merge.
#' @param bins1 the bins size for the first mass axis.
#' @param mz2 the second mass axis to merge.
#' @param intensity2 the spectral intensities corresponding to the second mass axis.
#' 
#' @return a list containing the common mass axis that represents mz1 and mz1 accurately and a boolean indicating if and error was raised.
#' @export
#' 
MergeMassAxis <- function(mz1, bins1, mz2, bins2) {
    .Call('_rMSI_MergeMassAxis', PACKAGE = 'rMSI', mz1, bins1, mz2, bins2)
}

ReduceDataPointsC <- function(mass, intensity, massMin, massMax, npoints) {
    .Call('_rMSI_ReduceDataPointsC', PACKAGE = 'rMSI', mass, intensity, massMin, massMax, npoints)
}

#' decodePngStream2IonImages.
#'
#' Obtain a multiple mass channel ion image by decoding the hdd img stream at a specified ionIndex.
#' The MAX operator will be used to merge all ion images in a single image matrix.
#'
#' @param ionIndex the index of ion to extract from the img stream. C style indexing, starting with zero.
#' @param ionCount number of ion image to decode.
#' @param normalization_coefs a vector containing the intensy normalization coeficients.
#' 
#' @return A NumerixMatrix containing the ion image.
#' 
NULL

#' TODO ideas varies:
#' 
NULL

#' - compatibilitat: puc fer que el nou rMSI i rMSIproc detecti automaticament si les dades son nou o antic format i ho carregui?
#' 
#' - comentar coses en el lodepng.h per fer el binary resultant mes petit: el que no facis servir fora! esta documentat en el propi lodepng.h
#' 
#' - imzML processats: no cal crear el imzML continu equivalent, pots mantenir el processat com a "ramdisk" i constriuir els png mitjancant funcio
#'   approx() o interpolacio. Aixi doncs, un paramatre sera l'eix de massa merged previament calculat. 
#'   Es a dir rMSI no convertira imzML processat en continu sino que simplement calculara leix d massa commu i fara servir una interpolacio quan calgui obtenir un espectre concret.
#'   El mateix passara en la part d processat d rMSIproc, en anar carregant espectres s'anira calculant la interpolacio "on the fly"
#'
#' - ajuntar rMSI i rMSIproc: importar tots els metodes de rMSIproc dins del rMSI, es a dir, rMSIproc deixara d existir. Aixi sera mes facil d mantenir.
#'   tb em permetra fer us d funcions d rMSIproc en rMSI (per exemple multi-threading d boost)
#'   oju amb el Namespace d R, crec que rMSI el fa automatic amb roxigen i rMSIproc el fa manual, que vull al final?
#'
#' - creacio d pngstream amb 2 threads. un thread accedeix a disc i l'altre fa encoding. 
#'   Axi sera mes rapid pq mentres un thread fa encoding laltre ja va carregnat el seguent buffer.
#'   
#' - Reconstruccio d'imatges multi-threading. Per construir la imatge dun io i mostrar-la per pantalla cal llegir N png's del pngstream 
#'   (on N correspont al numero d mass chanels o frames de disc), per tan N es correspon amb el valor de tolerancia selecionat per usuari.
#'   La lectura de disc la faria un sol thread k carregaria en RAM N frames. Despres, varis threads es poden repartir la feina de fer el decoding dels N frames.
#'     
NULL

#' Ccreate_rMSIXBinData.
#' 
#' creates new rMSIXBin files (.XrMSI and .BrMSI). Previous files will be deleted.
#'
#' @param rMSIobj: an rMSI object prefilled with a parsed imzML.
#' @return the rMSI object with rMSIXBin inforation completed. 
Ccreate_rMSIXBinData <- function(rMSIobj) {
    .Call('_rMSI_Ccreate_rMSIXBinData', PACKAGE = 'rMSI', rMSIobj)
}

#' Cload_rMSIXBinData.
#' 
#' Loads the data from the rMSIXBin files (.XrMSI and .BrMSI).
#' This method is used to load a previously stored rMSIXBin file.
#'
#' @param path: full path to the .XrMSI file.
#' @param fname: file name of the .XrMSI file without the extension.
#' @return the rMSI object with rMSIXBin inforation completed. 
Cload_rMSIXBinData <- function(path, fname) {
    .Call('_rMSI_Cload_rMSIXBinData', PACKAGE = 'rMSI', path, fname)
}

#' Cload_rMSIXBinIonImage.
#' 
#' loads a ion image from the .BrNSI img stream.
#' 
#' @param rMSIobj: an rMSI object prefilled with a parsed imzML.
#' @param ionIndex: the first mass channel at which the image starts.
#' @param ionCount: the numer of mass channels used to construct the ion image (a.k.a. image tolerance window).
#' @param normalization_coefs a vector containing the intensy normalization coeficients.
#' 
#' @return the ion image as a NumericMatrix using max operator with all the ion images of the mass channels. 
Cload_rMSIXBinIonImage <- function(rMSIobj, ionIndex, ionCount, normalization_coefs) {
    .Call('_rMSI_Cload_rMSIXBinIonImage', PACKAGE = 'rMSI', rMSIobj, ionIndex, ionCount, normalization_coefs)
}

