# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' ParseBrukerXML.
#'
#' Reads a Bruker's xml file exported using fleximaging.
#' A list is returned where each element in the list is named according the ROI name.
#' Each element in the list consists in a data.frame with the pixels XY coordinates inside each ROI.
#'
#' @param xml_path the full path where XML file is stored.
#'
#' @return ROI pixel coordinates arranged in a named list.
#' 
CparseBrukerXML <- function(xml_path) {
    .Call('_rMSI_CparseBrukerXML', PACKAGE = 'rMSI', xml_path)
}

#' Testing the imzMLreader
#' testingimzMLBinRead
#' @param ibdFname: full path to the ibd file.
#' @param NPixels: Total number of pixels in the image.
#' @param N: number of elemetns (or data point to read).
#' @param offset: offset in bytes at which the reading operation is started.
#' @param read_mz: if true m/z data is readed, otherwise intensities are readed.
#' @param continuous: true if imzML data is in continuous mode
.debug_imzMLBinReader <- function(ibdFname, NPixels, N, offset, dataTypeString, read_mz, continuous) {
    .Call('_rMSI_testingimzMLBinRead', PACKAGE = 'rMSI', ibdFname, NPixels, N, offset, dataTypeString, read_mz, continuous)
}

#' Testing the imzMLwriter in sequential mode
#' This function creates a new ibd file with the provided data descibed in the following params
#' @param ibdFname: full path to the ibd file.
#' @param mz_dataTypeString: String to specify the data format used to encode m/z values.
#' @param int_dataTypeString: String to specify the data format used to encode intensity values.
#' @param uuid: 16 bytes long UUID.
#' @param mzArray: A matrix with the m/z values for all pixels. Each pixel corresponds to a row. If there is only one row data will be saved in continuous mode
#' @param intArray: A matrix with the intensity values for all pixels. Each pixel corresponds to a row so the number of pixels is extracted from here.
.debug_imzMLBinWriterSequential <- function(ibdFname, mz_dataTypeString, int_dataTypeString, uuid, mzArray, intArray) {
    invisible(.Call('_rMSI_testingimzMLBinWriteSequential', PACKAGE = 'rMSI', ibdFname, mz_dataTypeString, int_dataTypeString, uuid, mzArray, intArray))
}

CimzMLParse <- function(xml_path) {
    .Call('_rMSI_CimzMLParse', PACKAGE = 'rMSI', xml_path)
}

CimzMLStore <- function(fname, imgInfo) {
    .Call('_rMSI_CimzMLStore', PACKAGE = 'rMSI', fname, imgInfo)
}

AlignSpectrumToReference <- function(mass, ref, spectrumInterpolated, massProcessedMode, intensityProcessedMode, bilinear = FALSE, lagRefLow = 0.1, lagRefMid = 0.5, lagRefHigh = 0.9, iterations = 1L, lagLimitppm = 200, fftOverSampling = 10L, winSizeRelative = 0.6) {
    .Call('_rMSI_AlignSpectrumToReference', PACKAGE = 'rMSI', mass, ref, spectrumInterpolated, massProcessedMode, intensityProcessedMode, bilinear, lagRefLow, lagRefMid, lagRefHigh, iterations, lagLimitppm, fftOverSampling, winSizeRelative)
}

#' CalcMassAxisBinSize.
#' 
#' Calc the bin size of a mass axis at each mass channels using simple peak-picking information.
#' 
#' @param mass the mass axis.
#' @param intensity the intensity of a given spectrum.
#' 
#' @return the bin size of each m/z channel.
#' @export
#' 
CalcMassAxisBinSize <- function(mass, intensity) {
    .Call('_rMSI_CalcMassAxisBinSize', PACKAGE = 'rMSI', mass, intensity)
}

#' MergeMassAxis.
#' 
#' Merges two mass axis in a single one using an apropiate bin size.
#' The resulting mass axis will display a bin size equal to the minimum of two supplied vectors. 
#' The bin size must be supplied along each input mass axis.
#' The first mass axis (mz1) can be a zero-length vector.
#' 
#' @param mz1 the first mass axis to merge.
#' @param bins1 the bins size for the first mass axis.
#' @param mz2 the second mass axis to merge.
#' @param intensity2 the spectral intensities corresponding to the second mass axis.
#' 
#' @return a list containing the common mass axis that represents mz1 and mz1 accurately and a boolean indicating if and error was raised.
#' 
MergeMassAxis <- function(mz1, bins1, mz2, bins2) {
    .Call('_rMSI_MergeMassAxis', PACKAGE = 'rMSI', mz1, bins1, mz2, bins2)
}

#' MergeMassAxisAutoBinSize.
#' 
#' Merges two mass axis in a single one using an apropiate bin size without having to specify the bin sizes.
#' The resulting mass axis will display a bin size equal to the minimum of two supplied vectors. 
#' The bin size is calculated relative to the m/z for better accuracy.
#' The resulting mass axis range is calculated using the common range between the two mass axis.
#' If there is no overlao between the two mass axis range an error will be raised.
#' 
#' @param mz1 the first mass axis to merge.
#' @param mz2 the second mass axis to merge.
#' 
#' @return a list containing the common mass axis that represents mz1 and mz1 accurately and a boolean indicating if and error was raised.
#' 
MergeMassAxisAutoBinSize <- function(mz1, mz2) {
    .Call('_rMSI_MergeMassAxisAutoBinSize', PACKAGE = 'rMSI', mz1, mz2)
}

COverallAverageSpectrum <- function(rMSIObj_list, numOfThreads, memoryPerThreadMB) {
    .Call('_rMSI_COverallAverageSpectrum', PACKAGE = 'rMSI', rMSIObj_list, numOfThreads, memoryPerThreadMB)
}

FullImageAlign <- function(rMSIObj_list, numOfThreads, memoryPerThreadMB, preProcessingParams, mass, reference) {
    .Call('_rMSI_FullImageAlign', PACKAGE = 'rMSI', rMSIObj_list, numOfThreads, memoryPerThreadMB, preProcessingParams, mass, reference)
}

ReduceDataPointsC <- function(mass, intensity, massMin, massMax, npoints) {
    .Call('_rMSI_ReduceDataPointsC', PACKAGE = 'rMSI', mass, intensity, massMin, massMax, npoints)
}

#' decodePngStream2IonImages.
#'
#' Obtain a multiple mass channel ion image by decoding the hdd img stream at a specified ionIndex.
#' The MAX operator will be used to merge all ion images in a single image matrix.
#'
#' @param ionIndex the index of ion to extract from the img stream. C style indexing, starting with zero.
#' @param ionCount number of ion image to decode.
#' @param normalization_coefs a vector containing the intensy normalization coeficients.
#' 
#' @return A NumerixMatrix containing the ion image.
#' 
NULL

#' TODO ideas varies:
#' 
#' - compatibilitat: puc fer que el nou rMSI i rMSIproc detecti automaticament si les dades son nou o antic format i ho carregui?
#'
#' - ajuntar rMSI i rMSIproc: importar tots els metodes de rMSIproc dins del rMSI, es a dir, rMSIproc deixara d existir. Aixi sera mes facil d mantenir.
#'   tb em permetra fer us d funcions d rMSIproc en rMSI (per exemple multi-threading d boost)
#'   oju amb el Namespace d R, crec que rMSI el fa automatic amb roxigen i rMSIproc el fa manual, que vull al final?
NULL

#' Ccreate_rMSIXBinData.
#' 
#' creates new rMSIXBin files (.XrMSI and .BrMSI). Previous files will be deleted.
#'
#' @param rMSIobj: an rMSI object prefilled with a parsed imzML.
#' @param number_of_threads: number of threads used for imgStream encoding.
#' @return the rMSI object with rMSIXBin inforation completed. 
Ccreate_rMSIXBinData <- function(rMSIobj, number_of_threads) {
    .Call('_rMSI_Ccreate_rMSIXBinData', PACKAGE = 'rMSI', rMSIobj, number_of_threads)
}

#' Cload_rMSIXBinData.
#' 
#' Loads the data from the rMSIXBin files (.XrMSI and .BrMSI).
#' This method is used to load a previously stored rMSIXBin file.
#'
#' @param path: full path to the .XrMSI file.
#' @param fname: file name of the .XrMSI file without the extension.
#' @return the rMSI object with rMSIXBin inforation completed. 
Cload_rMSIXBinData <- function(path, fname) {
    .Call('_rMSI_Cload_rMSIXBinData', PACKAGE = 'rMSI', path, fname)
}

#' Cload_rMSIXBinIonImage.
#' 
#' loads a ion image from the .BrNSI img stream.
#' 
#' @param rMSIobj: an rMSI object prefilled with a parsed imzML.
#' @param ionIndex: the first mass channel at which the image starts.
#' @param ionCount: the numer of mass channels used to construct the ion image (a.k.a. image tolerance window).
#' @param normalization_coefs a vector containing the intensy normalization coeficients.
#' @param number_of_threads: number of threads used for imgStream encoding.
#' 
#' @return the ion image as a NumericMatrix using max operator with all the ion images of the mass channels. 
Cload_rMSIXBinIonImage <- function(rMSIobj, ionIndex, ionCount, normalization_coefs, number_of_threads) {
    .Call('_rMSI_Cload_rMSIXBinIonImage', PACKAGE = 'rMSI', rMSIobj, ionIndex, ionCount, normalization_coefs, number_of_threads)
}

#' Cload_imzMLSpectra
#' Load spectra into a Matrix object interpolating to the common mass axis when necessary.
#' @param rMSIobj: an rMSI object prefilled with a parsed imzML.
#' @param pixelIDs: pixel ID's of the spectra to load in C-style indexing (starting at 0).
Cload_imzMLSpectra <- function(rMSIobj, pixelIDs) {
    .Call('_rMSI_Cload_imzMLSpectra', PACKAGE = 'rMSI', rMSIobj, pixelIDs)
}

